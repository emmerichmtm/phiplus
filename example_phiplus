import numpy as np
# from desdeo_problem.problem import MOProblem
# from desdeo_problem.problem import Variable
# from desdeo_problem.problem import ScalarObjective
from desdeo_emo.EAs.RVEA import RVEA
# from desdeo_emo.EAs.NSGAIII import NSGAIII
# from desdeo_emo.EAs.PBEA import PBEA
# from desdeo_emo.EAs.IBEA import IBEA
# from desdeo_emo.EAs.IOPIS import IOPIS_RVEA
import pandas as pd
from ori_phi import phi
from m_phi import mphi
# import warnings
import matplotlib.pyplot as plt
from desdeo_tools.utilities.fast_non_dominated_sorting import dominates
from desdeo_problem.testproblems import EngineeringRealWorld
import RE

# warnings.filterwarnings("ignore",category=DeprecationWarning)

#####################################Setting of problems####################################################

RE25 = EngineeringRealWorld.re25()
idealp25 = np.array([0.037591349242869145, 0.0])
RE25.update_ideal(idealp25,idealp25)
nadirp25 = np.array([0.40397042546, 2224669.22419])
refpoint25 = np.array([[0.3, 1800000], [0.1, 1800000], [0.2, 900000], [0.1,10000], [0.05, 10000], [0.05, 5000]])
lowerBound25 = np.zeros((6,2))
upperBound25 = np.zeros((6,2))
lowerBound25 = np.array([[0.15, 1710000], [-0.05, 1710000], [0.05, 810000], [0.075, 0], [0.025, 0], [0.025, -0.005]])
upperBound25 = np.array([[0.45, 1890000], [0.25, 1890000], [0.35, 990000], [0.125, 20000], [0.075, 20000], [0.075, 15000]])

RE23 = EngineeringRealWorld.re23()
idealp23 = np.array([15.9018007813, 0.0])
RE23.update_ideal(idealp23,idealp23)
nadirp23 = np.array([5852.05896876, 1288669.78054])
refpoint23 = np.array([[600, 10], [400, 10], [200, 10], [150,5], [130, 5], [100, 0]])
L_learning23 = np.array([300,20])
L_decision23 = np.array([150, 10])
lowerBound23 = np.zeros((6,2))
upperBound23 = np.zeros((6,2))
for l23 in range(3):
    lowerBound23[l23][0] = refpoint23[l23][0] - L_learning23[0]/2
    lowerBound23[l23][1] = refpoint23[l23][1] - L_learning23[1] / 2
    upperBound23[l23][0] = refpoint23[l23][0] + L_learning23[0]/2
    upperBound23[l23][1] = refpoint23[l23][1] + L_learning23[1] / 2
for l23 in range(3,6):
    lowerBound23[l23][0] = refpoint23[l23][0] - L_decision23[0]/2
    lowerBound23[l23][1] = refpoint23[l23][1] - L_decision23[1] / 2
    upperBound23[l23][0] = refpoint23[l23][0] + L_decision23[0]/2
    upperBound23[l23][1] = refpoint23[l23][1] + L_decision23[1] / 2

###################################################################################################
idealp = idealp25
nadirp = nadirp25
refpoint = refpoint25

lowerbound = lowerBound25
upperbound = upperBound25
tphi = phi(idealp)
mphi = mphi(idealp, nadirp)
###################################################################################################
for dup in range(1):  # Number of runs

    '''
    # name for saving
    algorithm_name = '_RVEA'
    proble_name = '_RE25'
    pop_size = '_pop100'
    generations = '_gens100'
    '''

    evolver = RVEA(RE25, interact=True, population_size=100, n_iterations=1, n_gen_per_iter=100)

    evolver.set_interaction_type('Reference point')
    pref, plot = evolver.start()  # return preference and plot information

    response = np.zeros(len(idealp))  # Initialize R
    solution = []

    p = np.zeros(6)  # record the PHI value in each iteration
    mp = np.zeros(6)  # record the PHI+ value in each iteration

    if len(response) == 2 or len(response) == 3:
        plt.ion()
    i = 0
    while i <= 5:  # 6 iterations, 6 preference information
        #######################################Calculate PHI and PHI+ values################################################
        response = refpoint[i]
        lb = lowerbound[i]
        ub= upperbound[i]

        pref.response = pd.DataFrame([response], columns=pref.content['dimensions_data'].columns)
        pref, plot = evolver.iterate(pref)
        nondominated_solutions = evolver.population.objectives[evolver.population.non_dominated_fitness()]
        all_solutions = evolver.population.objectives

        print("The reference point R in %d iteration: " % (i+1))
        print(response)
        res = np.zeros(len(nondominated_solutions))  # record a solution is dominated or dominates or non-dominated (to R)
        for j in range(0,len(nondominated_solutions)):
            temp = dominates(nondominated_solutions[j], response)
            if temp == True:  # if x[j] dominates R
                res[j] = 1
            else:
                temp = dominates(response,nondominated_solutions[j])  # if R dominates x[j]
                if temp == True:
                    res[j] = -1
                else:  # if x[j] and R are non-dominated to each other
                    res[j] = 0

        check_res = np.isin([1, -1, 0], res)
        solInROI_p= []
        solOutsideROI_p= []
        solInROI_mp = []
        solOutsideROI_mp = []
        # For PHI
        if check_res[0]: # if there is a 1 in res, namely there is a solution that dominates R
            sol_dominatesR = nondominated_solutions[res == 1]
            solInROI_p = sol_dominatesR
        elif check_res[1]: # if there is a -1 in res, namely there is a solution is dominated R
            sol_dominatedR = nondominated_solutions[res == -1]
            solInROI_p = sol_dominatedR
        if check_res[2]: # if there is a 0 in res, namely the solutions and R are non-dominated to each other
            # a = (res == 0)
            solOutsideROI_p = nondominated_solutions[res == 0]

        # For PHI+
        flag = 0  # check if R is dominated or not
        if check_res[0]:  # if there is a 1 in res, then there is a solution that dominates R
            sol_dominatesR = nondominated_solutions[res == 1]  # the solutions dominate R
            solInROI_mp = sol_dominatesR
            flag = 1  # R is dominated
            if check_res[2]: # if there is a 0 in res, then the solutions and R are non-dominated to each other
                sol_non_dominatedR = nondominated_solutions[res == 0]  # the solutions are non-dominated by R
                comp = np.ones(len(sol_non_dominatedR))
                for co in range(len(lb)):  # check if these solutions are in ROI+
                    sol = sol_non_dominatedR[:,co]
                    c1 = (sol >= lb[co])
                    c2 = (sol <= ub[co])
                    comp = np.logical_and(comp, c1)
                    comp = np.logical_and(comp, c2)
                if sum(comp) > 0:  # There exists at least one solution that is non-dominated by R and in ROI+
                    solIn_mp = sol_non_dominatedR[comp]
                    solInROI_mp = np.concatenate((sol_dominatesR, solIn_mp),axis=0)  # solutions in ROI+
                    if sum(comp) != len(sol_non_dominatedR): # If not all solutions are in ROI
                        solOutsideROI_mp = sol_non_dominatedR[~comp]
                else:
                    solOutsideROI_mp = sol_non_dominatedR
        else: # R is not dominated
            flag = 2
            comp = np.ones(len(nondominated_solutions))
            for co in range(len(lb)):  # check if these solutions are in ROI+
                sol = nondominated_solutions[:, co]
                c1 = (sol >= lb[co])
                c2 = (sol <= ub[co])
                comp = np.logical_and(comp, c1)
                comp = np.logical_and(comp, c2)
            if sum(comp) > 0:  # There exists at least one solution is within ROI
                solInROI_mp = nondominated_solutions[comp]  # solutions in ROI+
                solOutsideROI_mp = nondominated_solutions[~comp]
            else:
                solOutsideROI_mp = nondominated_solutions
        # solOutsideROI_mp = np.array(solOutsideROI_mp)
        # solInROI_mp = np.array(solInROI_mp)

        # calculate the PHI and the PHI+ value
        p[i], b, c, d = tphi.get_phi(set_of_s=nondominated_solutions, RP=response, nadir=nadirp)
        mp[i] = mphi.get_mphi(set_of_s=solInROI_mp, flag = flag, RP=response, ub = ub)

        print("Solutions in ROI(phi):")
        print(solInROI_p)
        print("Solutions outside ROI(phi):")
        print(solOutsideROI_p)
        if len(solInROI_p) != 0:
            print("the number of solutions in ROI(phi) is: ", len(solInROI_p))
        if len(solOutsideROI_p) != 0:
            print("the number of solutions outside ROI(phi) is: ", len(solOutsideROI_p))

        print("Solutions in ROI(mphi):")
        print(solInROI_mp)
        print("Solutions outside ROI(mphi):")
        print(solOutsideROI_mp)
        if len(solInROI_mp) != 0:
            print("the number of solutions in ROI(mphi) is: ", len(solInROI_mp))
        if len(solOutsideROI_mp) != 0:
            print("the number of solutions outside ROI(mphi) is: ", len(solOutsideROI_mp))


        '''
        # file_name1_1 = str(dup + 1)+'_times_'+str(i+1) + '_iters_PHI'
        # file_name1_2 = str(dup + 1) + '_times_' + str(i + 1) + '_iters_mPHI'
        file_name1_3 = str(dup + 1) + '_times_' + str(i + 1) + '_iters' + '_non_dominated' \
                       + algorithm_name + proble_name + pop_size + generations
        file_name1_4 = str(dup + 1) + '_times_' + str(i + 1) + '_iters' + '_all'\
                       + algorithm_name + proble_name + pop_size + generations
        # Define the path where you want to save the CSV file
        # file_path1_1 = "./results_data_phi/" + file_name1_1
        # file_path1_2 = "./results_data_mphi/" + file_name1_2
        file_path1_3 = "./results_data_non_dominated_solutions/" + file_name1_3
        file_path1_4 = "./results_data_solutions/" + file_name1_4

        # # Save the numpy arrays of phi to a CSV file
        # np.savetxt(file_path1_1, solInROI_p, delimiter=',')
        # with open(file_path1_1, 'ab') as f:
        #     np.savetxt(f, solOutsideROI_p, delimiter=',')
        # # Save data about mphi
        # np.savetxt(file_path1_2, solInROI_mp, delimiter=',')
        # with open(file_path1_2, 'ab') as f:
        #     np.savetxt(f, solOutsideROI_mp, delimiter=',')
        # Save non-dominated solutions
        np.savetxt(file_path1_3, nondominated_solutions, delimiter=',')
        # Save all solutions
        np.savetxt(file_path1_4, all_solutions, delimiter=',')
        '''

        print("-------------------------------")

        ###########################################plot figure#################################################################
        if len(response) == 2:  # 2D-scatter
            fig1 = plt.figure(1)
            ax1 = plt.subplot(3, 2, i + 1)
            if len(solOutsideROI_p) != 0:
                ax1.scatter(x=solOutsideROI_p[:, 0], y=solOutsideROI_p[:, 1], c='b', label="Solutions outside ROI",
                            alpha=0.6)
            if len(solInROI_p) != 0:
                ax1.scatter(x=solInROI_p[:, 0], y=solInROI_p[:, 1], c='lime', label="Solutions in ROI", alpha=0.6)
            ax1.scatter(x=response[0], y=response[1], c='r', alpha=0.6, label="Reference point", marker="D")  # diamond
            ax1.scatter(x=nadirp[0], y=nadirp[1], c='orange', alpha=0.6, label="Nadir point",
                        marker="v")  # triangle_down
            ax1.legend(loc="best")
            ax1.set_title("Iteration " + str(i + 1))

            fig2 = plt.figure(2)
            ax2 = plt.subplot(3, 2, i + 1)
            # plt.scatter(x=nondominated_solutions[:, 0], y=nondominated_solutions[:, 1], label="Solutions", alpha=0.8)
            if len(solOutsideROI_mp) != 0:
                ax2.scatter(x=solOutsideROI_mp[:, 0], y=solOutsideROI_mp[:, 1], c='b', label="Solutions outside ROI",
                            alpha=0.6)
            if len(solInROI_mp) != 0:
                ax2.scatter(x=solInROI_mp[:, 0], y=solInROI_mp[:, 1], c='lime', label="Solutions in ROI", alpha=0.6)
            ax2.scatter(x=response[0], y=response[1], c='r', alpha=0.6, label="Reference point", marker="D")  # pentagon
            ax2.scatter(x=nadirp[0], y=nadirp[1], c='orange', alpha=0.6, label="Nadir point",
                        marker="v")  # triangle_down
            ax2.scatter(x=ub[0], y=ub[1], c='darkgoldenrod', alpha=0.6, label="Upper limit point",
                        marker="^")  # triangle_up
            # plt.xlim(1500, 2500)
            ax2.legend(loc="best")
            ax2.set_title("Iteration " + str(i + 1))

        elif len(response) == 3:  # 3D-scatter
            fig1 = plt.figure(1)
            ax1 = plt.subplot(3, 2, i + 1, projection='3d')
            if len(solOutsideROI_p) != 0:
                ax1.scatter(xs=solOutsideROI_p[:, 0], ys=solOutsideROI_p[:, 1], zs=solOutsideROI_p[:, 2], c='b',
                            label="Solutions outside ROI", alpha=0.6)
            if len(solInROI_p) != 0:
                ax1.scatter(xs=solInROI_p[:, 0], ys=solInROI_p[:, 1], zs=solInROI_p[:, 2], c='lime',
                            label="Solutions in ROI", alpha=0.6)
            ax1.scatter(xs=response[0], ys=response[1], zs=response[2], c='r', alpha=0.6, label="Reference point",
                        marker="D")
            ax1.scatter(xs=nadirp[0], ys=nadirp[1], zs=nadirp[2], c='orange', alpha=0.6, label="Nadir point",
                        marker="v")
            ax1.set_title("Iteration " + str(i + 1))

            fig2 = plt.figure(2)
            ax2 = plt.subplot(3, 2, i + 1, projection='3d')
            if len(solOutsideROI_mp) != 0:
                ax2.scatter(xs=solOutsideROI_mp[:, 0], ys=solOutsideROI_mp[:, 1], zs=solOutsideROI_mp[:, 2], c='b',
                            label="Solutions outside ROI", alpha=0.6)
            if len(solInROI_mp) != 0:
                ax2.scatter(xs=solInROI_mp[:, 0], ys=solInROI_mp[:, 1], zs=solInROI_mp[:, 2], c='lime',
                            label="Solutions in ROI", alpha=0.6)
            ax2.scatter(xs=response[0], ys=response[1], zs=response[2], c='r', alpha=0.6, label="Reference point",
                        marker="D")
            ax2.scatter(xs=nadirp[0], ys=nadirp[1], zs=nadirp[2], c='orange', alpha=0.6, label="Nadir point",
                        marker="v")
            ax2.scatter(xs=ub[0], ys=ub[1], zs=ub[2], c='darkgoldenrod', alpha=0.6, label="Upper limit point",
                        marker="^")
            ax2.set_title("Iteration " + str(i + 1))

        i += 1

    print("===================================")
    np.set_printoptions(precision=10, suppress=True)  # scientific notation
    print("PHI:")
    print(p)
    print("PHI+")
    print(mp)

    '''
    file_name2_1 = str(dup + 1) + '_times_' + 'phi' + algorithm_name + proble_name + pop_size + generations
    # Define the path where you want to save the CSV file
    file_path2_1 = "./results_data_phi/" + file_name2_1
    # Save the numpy arrays to the CSV file
    np.savetxt(file_path2_1, np.array(p), delimiter=',')

    file_name2_2 = str(dup + 1) + '_times_' + 'mphi' + algorithm_name + proble_name + pop_size + generations
    # Define the path where you want to save the CSV file
    file_path2_2 = "./results_data_mphi/" + file_name2_2
    # Save the numpy arrays to the CSV file
    np.savetxt(file_path2_2, np.array(mp), delimiter=',')
   '''

    if len(response) == 2 or len(response) == 3:
        plt.ioff()
        fig1.tight_layout()
        fig2.tight_layout()


        fig1.canvas.manager.full_screen_toggle()
        fig2.canvas.manager.full_screen_toggle()
        
        '''
        file_name3_1 = str(dup + 1) + '_times_phi' + algorithm_name + proble_name + pop_size + generations + '.png'
        # Define the path where you want to save the CSV file
        file_path3_1 = "./results_figure/" + file_name3_1
        fig1.savefig(file_path3_1)

        file_name3_2 = str(dup + 1) + '_times_mphi' + algorithm_name + proble_name + pop_size + generations + '.png'
        # Define the path where you want to save the CSV file
        file_path3_2 = "./results_figure/" + file_name3_2
        fig2.savefig(file_path3_2)
        '''

        plt.show()
        # plt.show(block=False)
        # plt.close('all')




